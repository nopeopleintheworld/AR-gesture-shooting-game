<!doctype html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>AR 手势射击（修复版）</title>
		<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%230b84ff'/%3E%3Ctext x='50%25' y='55%25' font-size='9' text-anchor='middle' fill='white' font-family='system-ui,Segoe UI,Arial'%3EAR%3C/text%3E%3C/svg%3E">
		<style>
			html,body{height:100%;margin:0;overflow:hidden;background:#111;color:#fff;font-family:system-ui,Segoe UI,Arial}
			#container{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
			canvas{display:block}
			#ui{position:fixed;left:16px;top:16px;color:#fff;z-index:5}
			#overlay{position:fixed;inset:0;background:linear-gradient(180deg,#000c, #0008);display:flex;align-items:center;justify-content:center;z-index:20}
			#loadingCard{background:#0f1720;border-radius:12px;padding:20px;color:#dfe7ff;display:flex;flex-direction:column;align-items:center;gap:12px;box-shadow:0 10px 40px #0008}
			#progress{width:340px;height:10px;background:#0b1220;border-radius:6px;overflow:hidden}
			#progress > i{display:block;height:100%;background:linear-gradient(90deg,#6ee7b7,#60a5fa);width:0%;transition:width 300ms}
			#status{font-size:13px;color:#8ea7ff;}
			.hint{font-size:12px;color:#b8c7ff88;margin-top:6px}
			.hud{position:fixed;inset:auto 16px 16px 16px;display:flex;justify-content:space-between;z-index:5}
			.score{background:#000a;padding:10px 14px;border-radius:10px;color:#fff;backdrop-filter:blur(6px)}
			#msgLayer{position:fixed;inset:0;pointer-events:none;z-index:8}
			.floatingText{position:absolute;font-weight:700;text-shadow:0 2px 12px #0008;font-size:28px;opacity:1;transform:translate(-50%,-50%) translateY(0);transition:transform 700ms ease-out,opacity 700ms}
			#debug{position:fixed;right:16px;top:16px;color:#aab8ff66;font-size:12px;z-index:5}
			button{background:#0b84ff;border:none;color:white;padding:8px 12px;border-radius:8px;font-weight:600}
			#errorMessage{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#ff4444;padding:20px;border-radius:8px;z-index:100;max-width:80%}
		</style>
	</head>
	<body>
		<div id="container"></div>

		<div id="overlay">
			<div id="loadingCard">
				<div style="font-size:18px;font-weight:700">加载中 — 初始化模型和资源</div>
				<div id="progress"><i></i></div>
				<div id="status">准备下载 MediaPipe Hands...</div>
				<div class="hint">请允许摄像头权限 — 下载完毕后自动进入游戏。</div>
				<button id="retryBtn" style="display:none;margin-top:10px" onclick="window.location.reload()">重试</button>
			</div>
		</div>

		<div id="ui">
			<div style="display:flex;gap:8px;align-items:center">
				<div class="score">Score: <span id="scoreVal">0</span></div>
				<div class="score">Enemies: <span id="enemyCount">0</span></div>
			</div>
			<div class="hint">手势：食指瞄准 + 拇指靠近食指触发射击</div>
		</div>

		<div class="hud">
			<div class="score">FPS: <span id="fps">0</span></div>
			<div class="score">Mode: AR Gesture Shooter</div>
		</div>

		<div id="msgLayer"></div>
		<div id="debug"></div>
		<div id="errorMessage" style="display:none"></div>

		<script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
		<script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1646425229/camera_utils.js"></script>
		<script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1646425229/drawing_utils.js"></script>

		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
			
			// Configuration
			const MAX_ENEMIES = 4;
			const AI_DETECTION_HZ = 10;
			const MEDIAPIPE_VERSION = '0.4.1646424915';

			// UI Elements
			const overlay = document.getElementById('overlay');
			const progressBar = document.querySelector('#progress > i');
			const statusText = document.getElementById('status');
			const retryBtn = document.getElementById('retryBtn');
			const errorMessage = document.getElementById('errorMessage');
			
			// Game State
			let score = 0;
			let enemies = [];
			let lastDetectionTime = 0;
			let firingLocked = false;
			let shouldRender = true;
			let mediaPipeReady = false;

			// Three.js Objects
			let scene, camera, renderer, reticle, laser, videoTexture, bgMesh;

			// MediaPipe Objects
			let hands, cameraUtils, video;

			// Set loading progress
			function setLoading(progressPct, text) {
				progressBar.style.width = `${progressPct}%`;
				if (text) statusText.textContent = text;
			}

			// Show error message
			function showError(message) {
				errorMessage.textContent = message;
				errorMessage.style.display = 'block';
				retryBtn.style.display = 'block';
				setLoading(100, '错误：' + message);
				console.error(message);
			}

			// Initialize Three.js
			function initThreeJS() {
				try {
					// Create renderer
					renderer = new THREE.WebGLRenderer({ 
						alpha: true, 
						antialias: true,
						powerPreference: "high-performance"
					});
					renderer.setSize(window.innerWidth, window.innerHeight);
					renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
					renderer.setClearColor(0x000000, 0);
					document.getElementById('container').appendChild(renderer.domElement);

					// Create scene
					scene = new THREE.Scene();

					// Create camera
					camera = new THREE.PerspectiveCamera(
						70, 
						window.innerWidth / window.innerHeight, 
						0.01, 
						2000
					);
					camera.position.set(0, 0, 12);

					// Create reticle (aiming circle)
					reticle = new THREE.Mesh(
						new THREE.RingGeometry(0.2, 0.35, 32), 
						new THREE.MeshBasicMaterial({ 
							color: 0xff0055, 
							side: THREE.DoubleSide,
							transparent: true,
							opacity: 0.8
						})
					);
					reticle.rotation.x = -Math.PI / 2;
					reticle.position.z = 0;
					scene.add(reticle);

					// Create laser
					const laserMaterial = new THREE.LineBasicMaterial({ 
						color: 0xff0055,
						linewidth: 2 
					});
					const laserGeometry = new THREE.BufferGeometry().setFromPoints([
						new THREE.Vector3(0, 0, 10),
						new THREE.Vector3(0, 0, 0)
					]);
					laser = new THREE.Line(laserGeometry, laserMaterial);
					scene.add(laser);

					// Handle window resize
					window.addEventListener('resize', () => {
						camera.aspect = window.innerWidth / window.innerHeight;
						camera.updateProjectionMatrix();
						renderer.setSize(window.innerWidth, window.innerHeight);
						if (bgMesh) {
							bgMesh.scale.set(window.innerWidth / window.innerHeight * 16, 16, 1);
						}
					});

					return true;
				} catch (error) {
					showError('Three.js初始化失败: ' + error.message);
					return false;
				}
			}

			// Initialize video and camera
			async function initCamera() {
				try {
					setLoading(20, '请求摄像头权限...');
					
					// Create video element
					video = document.createElement('video');
					video.autoplay = true;
					video.playsInline = true;
					video.muted = true;

					// Get camera stream
					const stream = await navigator.mediaDevices.getUserMedia({
						video: {
							facingMode: 'environment',
							width: { ideal: 1280 },
							height: { ideal: 720 }
						},
						audio: false
					});

					video.srcObject = stream;
					
					// Wait for video to load
					await new Promise(resolve => {
						video.addEventListener('loadeddata', resolve, { once: true });
					});

					// Create video background
					videoTexture = new THREE.VideoTexture(video);
					videoTexture.minFilter = THREE.LinearFilter;
					videoTexture.magFilter = THREE.LinearFilter;
					videoTexture.format = THREE.RGBAFormat;

					const bgMat = new THREE.MeshBasicMaterial({ 
						map: videoTexture, 
						toneMapped: false 
					});
					const bgGeo = new THREE.PlaneGeometry(
						window.innerWidth / window.innerHeight * 16, 
						16
					);
					bgMesh = new THREE.Mesh(bgGeo, bgMat);
					bgMesh.position.set(0, 0, -10);
					scene.add(bgMesh);

					setLoading(40, '摄像头初始化成功');
					return true;
				} catch (error) {
					showError('摄像头初始化失败: ' + error.message);
					return false;
				}
			}

			// Initialize MediaPipe Hands
			async function initMediaPipe() {
				try {
					setLoading(60, '初始化手部追踪模型...');

					// Initialize MediaPipe Hands
					hands = new Hands({
						locateFile: (file) => {
							return `https://unpkg.com/@mediapipe/hands@${MEDIAPIPE_VERSION}/${file}`;
						}
					});

					hands.setOptions({
						maxNumHands: 1,
						modelComplexity: 0,
						minDetectionConfidence: 0.7,
						minTrackingConfidence: 0.6,
						selfieMode: true
					});

					// Store last results
					let lastResults = null;
					hands.onResults((results) => {
						lastResults = results;
					});

					// Initialize camera utils
					cameraUtils = new Camera(video, {
						onFrame: async () => {
							if (mediaPipeReady && Date.now() - lastDetectionTime > (1000 / AI_DETECTION_HZ)) {
								lastDetectionTime = Date.now();
								try {
									await hands.send({ image: video });
								} catch (error) {
									console.warn('MediaPipe发送帧失败:', error);
								}
							}
						},
						width: 640,
						height: 480
					});

					await cameraUtils.start();
					mediaPipeReady = true;

					setLoading(80, '手部追踪模型初始化完成');
					return lastResults;
				} catch (error) {
					showError('MediaPipe初始化失败: ' + error.message);
					return null;
				}
			}

			// Spawn enemy
			function spawnEnemy() {
				if (enemies.length >= MAX_ENEMIES) return;

				const angle = Math.random() * Math.PI * 2;
				const radius = 10 + Math.random() * 5;
				const x = Math.cos(angle) * radius;
				const y = Math.sin(angle) * radius;

				const enemyGeo = new THREE.CircleGeometry(0.6, 32);
				const mat = new THREE.MeshBasicMaterial({
					color: new THREE.Color(`hsl(${Math.random() * 360}, 80%, 60%)`),
					opacity: 0.95,
					transparent: true
				});

				const enemy = new THREE.Mesh(enemyGeo, mat);
				enemy.position.set(x, y, 0);
				enemy.userData = {
					vel: new THREE.Vector3(
						-x * (0.004 + Math.random() * 0.002),
						-y * (0.004 + Math.random() * 0.002),
						0
					),
					hp: 1
				};

				scene.add(enemy);
				enemies.push(enemy);
				updateHUD();
			}

			// Update HUD
			function updateHUD() {
				document.getElementById('scoreVal').textContent = score;
				document.getElementById('enemyCount').textContent = enemies.length;
			}

			// Play sound effect
			const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			function playSound(type) {
				try {
					const oscillator = audioCtx.createOscillator();
					const gainNode = audioCtx.createGain();

					oscillator.connect(gainNode);
					gainNode.connect(audioCtx.destination);

					switch(type) {
						case 'shoot':
							oscillator.type = 'sine';
							oscillator.frequency.value = 700;
							gainNode.gain.value = 0.2;
							oscillator.start();
							gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
							oscillator.stop(audioCtx.currentTime + 0.1);
							break;
						case 'hit':
							oscillator.type = 'sine';
							oscillator.frequency.value = 1200;
							gainNode.gain.value = 0.3;
							oscillator.start();
							gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
							oscillator.stop(audioCtx.currentTime + 0.08);
							break;
						case 'miss':
							oscillator.type = 'sine';
							oscillator.frequency.value = 300;
							gainNode.gain.value = 0.2;
							oscillator.start();
							gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
							oscillator.stop(audioCtx.currentTime + 0.1);
							break;
					}
				} catch (error) {
					console.warn('Audio error:', error);
				}
			}

			// Show floating text
			function showFloatingText(text, x, y) {
				const msgLayer = document.getElementById('msgLayer');
				const textElement = document.createElement('div');
				textElement.className = 'floatingText';
				textElement.textContent = text;
				textElement.style.left = `${x}%`;
				textElement.style.top = `${y}%`;
				textElement.style.color = text === 'HIT' ? '#4CAF50' : '#FF5252';
				
				msgLayer.appendChild(textElement);
				
				setTimeout(() => {
					textElement.style.transform = 'translate(-50%, -50%) translateY(-40px)';
					textElement.style.opacity = '0';
				}, 10);
				
				setTimeout(() => {
					msgLayer.removeChild(textElement);
				}, 800);
			}

			// Main game loop
			function gameLoop() {
				if (!shouldRender) return;

				requestAnimationFrame(gameLoop);

				// Update FPS counter
				updateFPS();

				// Update enemies
				updateEnemies();

				// Process hand tracking
				processHandTracking();

				// Render scene
				if (renderer && scene && camera) {
					renderer.render(scene, camera);
				}
			}

			// FPS counter
			let fpsCounter = 0;
			let fpsTime = performance.now();
			function updateFPS() {
				fpsCounter++;
				const now = performance.now();
				
				if (now - fpsTime >= 1000) {
					const fps = Math.round(fpsCounter * 1000 / (now - fpsTime));
					document.getElementById('fps').textContent = fps;
					fpsCounter = 0;
					fpsTime = now;
				}
			}

			// Update enemy positions
			function updateEnemies() {
				for (let i = enemies.length - 1; i >= 0; i--) {
					const enemy = enemies[i];
					
					// Move enemy
					enemy.position.add(enemy.userData.vel);
					
					// Check if enemy reached center
					if (enemy.position.length() < 0.8) {
						// Remove enemy
						scene.remove(enemy);
						enemies.splice(i, 1);
						
						// Decrease score
						score = Math.max(0, score - 5);
						showFloatingText('MISS', 50 + (Math.random() * 10 - 5), 50 + (Math.random() * 10 - 5));
						playSound('miss');
						updateHUD();
					}
				}

				// Spawn new enemies if needed
				while (enemies.length < MAX_ENEMIES) {
					spawnEnemy();
				}
			}

			// Process hand tracking data
			function processHandTracking() {
				if (!hands || !mediaPipeReady) return;

				hands.onResults(results => {
					if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
						const landmarks = results.multiHandLandmarks[0];
						
						// Get key landmarks
						const indexTip = landmarks[8];
						const thumbTip = landmarks[4];
						const wrist = landmarks[0];

						// Convert normalized coordinates to game space
						const aimX = (indexTip.x - 0.5) * (window.innerWidth / window.innerHeight) * 12;
						const aimY = -(indexTip.y - 0.5) * 12;

						// Update reticle position
						const aimPosition = new THREE.Vector3(aimX, aimY, 0);
						
						// Magnet effect - snap to nearest enemy
						const magnetRadius = 1.2;
						let nearestEnemy = null;
						let nearestDistance = Infinity;

						enemies.forEach(enemy => {
							const distance = enemy.position.distanceTo(aimPosition);
							if (distance < nearestDistance) {
								nearestDistance = distance;
								nearestEnemy = enemy;
							}
						});

						// Update reticle position
						if (nearestEnemy && nearestDistance < magnetRadius) {
							reticle.position.copy(nearestEnemy.position);
						} else {
							reticle.position.copy(aimPosition);
						}

						// Update laser
						laser.geometry.setFromPoints([
							new THREE.Vector3(0, 0, 10),
							reticle.position
						]);

						// Detect shooting gesture
						const isShooting = detectShootingGesture(landmarks);
						
						if (isShooting && !firingLocked) {
							firingLocked = true;
							setTimeout(() => firingLocked = false, 200);
							
							playSound('shoot');
							
							// Check for hit
							if (nearestEnemy && nearestDistance < magnetRadius) {
								// Hit enemy
								scene.remove(nearestEnemy);
								const index = enemies.indexOf(nearestEnemy);
								if (index !== -1) enemies.splice(index, 1);
								
								score += 10;
								showFloatingText('HIT', indexTip.x * 100, indexTip.y * 100);
								playSound('hit');
								updateHUD();
							} else {
								// Miss
								showFloatingText('MISS', indexTip.x * 100, indexTip.y * 100);
								playSound('miss');
							}
						}

						// Hide loading overlay
						if (overlay.style.display !== 'none') {
							setLoading(100, '准备就绪！');
							setTimeout(() => {
								overlay.style.display = 'none';
							}, 500);
						}
					}
				});
			}

			// Detect shooting gesture
			function detectShootingGesture(landmarks) {
				// Check if index finger is extended
				const indexExtended = isFingerExtended(landmarks, 8, 6);
				
				// Check if other fingers are curled
				const middleCurled = isFingerCurled(landmarks, 12, 10);
				const ringCurled = isFingerCurled(landmarks, 16, 14);
				const pinkyCurled = isFingerCurled(landmarks, 20, 18);
				
				// Check if thumb is near index finger
				const thumbNearIndex = getDistance(landmarks[4], landmarks[8]) < 0.06;

				return indexExtended && middleCurled && ringCurled && pinkyCurled && thumbNearIndex;
			}

			// Helper: Check if finger is extended
			function isFingerExtended(landmarks, tipIndex, pipIndex) {
				const tip = landmarks[tipIndex];
				const pip = landmarks[pipIndex];
				const wrist = landmarks[0];
				
				const tipDistance = getDistance(tip, wrist);
				const pipDistance = getDistance(pip, wrist);
				
				return tipDistance > pipDistance + 0.02;
			}

			// Helper: Check if finger is curled
			function isFingerCurled(landmarks, tipIndex, pipIndex) {
				const tip = landmarks[tipIndex];
				const pip = landmarks[pipIndex];
				const wrist = landmarks[0];
				
				const tipDistance = getDistance(tip, wrist);
				const pipDistance = getDistance(pip, wrist);
				
				return tipDistance < pipDistance + 0.01;
			}

			// Helper: Calculate distance between two landmarks
			function getDistance(point1, point2) {
				return Math.hypot(point1.x - point2.x, point1.y - point2.y);
			}

			// Initialize everything
			async function init() {
				try {
					setLoading(10, '初始化Three.js...');
					
					// Initialize Three.js
					if (!initThreeJS()) return;

					// Initialize camera
					if (!await initCamera()) return;

					// Initialize MediaPipe
					const results = await initMediaPipe();
					if (!results) return;

					// Start game loop
					setLoading(100, '游戏加载完成！');
					setTimeout(() => {
						overlay.style.display = 'none';
						gameLoop();
					}, 1000);

				} catch (error) {
					showError('初始化失败: ' + error.message);
				}
			}

			// Start initialization when DOM is loaded
			document.addEventListener('DOMContentLoaded', init);

			// Handle page visibility
			document.addEventListener('visibilitychange', () => {
				shouldRender = !document.hidden;
				if (shouldRender && renderer) {
					gameLoop();
				}
			});

			// Keep progress bar moving during loading
			let progress = 0;
			const progressInterval = setInterval(() => {
				if (progress < 90 && !mediaPipeReady) {
					progress += 2;
					setLoading(progress);
				} else if (mediaPipeReady) {
					clearInterval(progressInterval);
				}
			}, 500);
		</script>
	</body>
</html>