<!doctype html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>AR 手势射击（单文件）</title>
		<!-- small inline SVG favicon to avoid 404 on /favicon.ico -->
		<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%230b84ff'/%3E%3Ctext x='50%25' y='55%25' font-size='9' text-anchor='middle' fill='white' font-family='system-ui,Segoe UI,Arial'%3EAR%3C/text%3E%3C/svg%3E">
		<style>
			html,body{height:100%;margin:0;overflow:hidden;background:#111;color:#fff;font-family:system-ui,Segoe UI,Arial}
			#container{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
			canvas{display:block}
			#ui{position:fixed;left:16px;top:16px;color:#fff;z-index:5}
			#overlay{position:fixed;inset:0;background:linear-gradient(180deg,#000c, #0008);display:flex;align-items:center;justify-content:center;z-index:20}
			#loadingCard{background:#0f1720;border-radius:12px;padding:20px;color:#dfe7ff;display:flex;flex-direction:column;align-items:center;gap:12px;box-shadow:0 10px 40px #0008}
			#progress{width:340px;height:10px;background:#0b1220;border-radius:6px;overflow:hidden}
			#progress > i{display:block;height:100%;background:linear-gradient(90deg,#6ee7b7,#60a5fa);width:0%;transition:width 300ms}
			#status{font-size:13px;color:#8ea7ff;}
			.hint{font-size:12px;color:#b8c7ff88;margin-top:6px}
			.hud{position:fixed;inset:auto 16px 16px 16px;display:flex;justify-content:space-between;z-index:5}
			.score{background:#000a;padding:10px 14px;border-radius:10px;color:#fff;backdrop-filter:blur(6px)}
			#msgLayer{position:fixed;inset:0;pointer-events:none;z-index:8}
			.floatingText{position:absolute;font-weight:700;text-shadow:0 2px 12px #0008;font-size:28px;opacity:1;transform:translate(-50%,-50%) translateY(0);transition:transform 700ms ease-out,opacity 700ms}
			#debug{position:fixed;right:16px;top:16px;color:#aab8ff66;font-size:12px;z-index:5}
			button{background:#0b84ff;border:none;color:white;padding:8px 12px;border-radius:8px;font-weight:600}
		</style>
	</head>
	<body>
		<div id="container"></div>

		<div id="overlay" aria-hidden>
			<div id="loadingCard">
				<div style="font-size:18px;font-weight:700">加载中 — 初始化模型和资源</div>
				<div id="progress"><i></i></div>
				<div id="status">准备下载 MediaPipe Hands (锁定版本: 0.4.1646424915)</div>
				<div class="hint">请允许摄像头权限 — 下载完毕后自动进入游戏。</div>
			</div>
		</div>

		<div id="ui">
			<div style="display:flex;gap:8px;align-items:center">
				<div class="score">Score: <span id="scoreVal">0</span></div>
				<div class="score">Enemies: <span id="enemyCount">0</span></div>
			</div>
			<div class="hint">手势：食指瞄准 + 拇指靠近食指触发射击</div>
		</div>

		<div class="hud">
			<div class="score">FPS: <span id="fps">0</span></div>
			<div class="score">Mode: AR Gesture Shooter</div>
		</div>

		<div id="msgLayer"></div>
		<div id="debug"></div>

		<!-- Three.js (stable pinned) -->
		<!-- NOTE: build/three.min.js is deprecated in r150+. We will import the ES module version inside the main app script. -->

		<!-- MediaPipe resources (prefer local ./mediapipe/ copies to avoid CORS/tracking blocks) -->
		<script src="./mediapipe/hands.js"></script>
		<script src="./mediapipe/camera_utils.js"></script>
		<script src="./mediapipe/drawing_utils.js"></script>

		<script type="module">
			// Import three.js as an ES module so we avoid using deprecated builds
			import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
			// ==========================
			// Configuration / constants
			// ==========================
			const MAX_ENEMIES = 4;
			const AI_DETECTION_HZ = 12; // limit detections to 12/sec (throttled)
			const MEDIAPIPE_VERSION = '0.4.1646424915';

			// ===============
			// UI helpers
			// ===============
			const overlay = document.getElementById('overlay');
			const prog = document.querySelector('#progress > i');
			const status = document.getElementById('status');
			function setLoading(progressPct, text){ prog.style.width = progressPct + '%'; if(text) status.textContent = text; }

			// ====================
			// Safety: wait model
			// ====================
			// Base used by MediaPipe locateFile; prefer local ./mediapipe/ directory (avoid CORS), otherwise fall back to unpkg
			let MEDIAPIPE_ASSET_BASE = null;

			async function ensureMediaPipeReady(){
							// Prefer local ./mediapipe/ files (this avoids CORS problems with WASM on some CDNs).
							const localBase = './mediapipe/';
							const remoteCandidates = [
								`https://unpkg.com/@mediapipe/hands@${MEDIAPIPE_VERSION}/`,
								`https://cdn.jsdelivr.net/npm/@mediapipe/hands@${MEDIAPIPE_VERSION}/`
							];
							const list = ['hands.js','hands_solution_packed_assets.data','hands_cpu.wasm'];
							setLoading(5, '预热下载...');

							// Quick local check (HEAD requests). If at least two assets exist locally we prefer local files.
							let foundLocal = 0;
							for(const f of list){
								try{ const r = await fetch(localBase + f, {method:'HEAD'}); if(r.ok) foundLocal++; }catch(e){ /* ignore */ }
							}
							if(foundLocal >= 2){
								MEDIAPIPE_ASSET_BASE = localBase;
								setLoading(100,'本地模型资源已就绪 — 使用 ./mediapipe/');
								await new Promise(r => setTimeout(r, 400));
								return;
							}

							// No/partial local assets found -> try remote CDNs (some CDNs block wasm via CORS). Try candidates in order and pick the first that returns OK.
							let chosenRemote = null; let progress = 0;
							for(const candidate of remoteCandidates){
								try{
									setLoading(Math.min(90, progress + 10), `Checking remote CDN availability: ${candidate}`);
									// Try fetching the wasm file using CORS mode; if the CDN blocks cross-origin access this will throw or fail
									const res = await fetch(candidate + 'hands_cpu.wasm', {method:'GET', mode:'cors'});
									if(res.ok){ chosenRemote = candidate; break; }
								}catch(e){
									console.warn('Remote CDN check failed for', candidate, e);
								}
								progress += 40;
							}

							if(chosenRemote){
								MEDIAPIPE_ASSET_BASE = chosenRemote;
								setLoading(100, '使用可访问的 CDN 加载模型（远端）');
							}else{
								// Nothing usable remotely; ask the user to download assets to ./mediapipe.
								MEDIAPIPE_ASSET_BASE = localBase;
								setLoading(100,'无法直接从 CDN 获取 WASM（CORS 限制）。请运行脚本 scripts/fetch_mediapipe_assets.ps1 将资产保存至 ./mediapipe/');
								// show more visible message to user
								status.textContent = '无法从 CDN 获取 WASM；请在项目根目录运行 scripts/fetch_mediapipe_assets.ps1 下载必需文件到 ./mediapipe/ ，或手动添加这些文件。';
							}

							await new Promise(r => setTimeout(r, 400));
						}

			// ==================================================
			// Begin main application lifecycle (async to await models)
			// ==================================================
			(async function main(){
				try{
					// Ensure MediaPipe assets reachable (blocking to prevent WASM mismatch crashes)
					await ensureMediaPipeReady();

					// Camera setup
					status.textContent = '请求摄像头权限...';
					let stream;
					try{
						stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
					}catch(deviceErr){
						console.error('Camera acquisition failed', deviceErr);
						// Provide a clear user message rather than letting a raw NotFoundError bubble up
						document.getElementById('status').textContent = '无法访问摄像头 — 请检查摄像头是否连接并允许权限。';
						setLoading(100,'需要摄像头才能运行');
						// hide the overlay only after user acknowledges, but for now stop startup
						return;
					}

					// create a hidden video element
					const video = document.createElement('video');
					video.autoplay = true; video.playsInline = true; video.muted = true;
					video.srcObject = stream;
					await new Promise(r => video.addEventListener('loadeddata',r,{once:true}));

					// Setup Three.js renderer
					const container = document.getElementById('container');
					const renderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
					renderer.setSize(window.innerWidth, window.innerHeight);
					renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 1.5));
					container.appendChild(renderer.domElement);

					window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth,window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

					// Create scene & camera
					const scene = new THREE.Scene();
					const camera = new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,2000);
					camera.position.set(0,0,12);

					// Add a subtle background plane textured with webcam
					const videoTexture = new THREE.VideoTexture(video);
					videoTexture.minFilter = THREE.LinearFilter; videoTexture.magFilter = THREE.LinearFilter; videoTexture.format = THREE.RGBAFormat;
					const bgMat = new THREE.MeshBasicMaterial({map: videoTexture, toneMapped:false});
					const bgGeo = new THREE.PlaneGeometry(window.innerWidth/window.innerHeight*16, 16);
					const bgMesh = new THREE.Mesh(bgGeo,bgMat);
					bgMesh.position.set(0,0,-10);
					scene.add(bgMesh);

					// Reticle and UI objects
					const reticle = new THREE.Mesh(new THREE.RingGeometry(0.2,0.35,32), new THREE.MeshBasicMaterial({color:0xfffa, side:THREE.DoubleSide}));
					reticle.rotation.x = Math.PI/2; reticle.position.z = 0; scene.add(reticle);

					// Laser line
					const laserMaterial = new THREE.LineBasicMaterial({color:0xff0055,linewidth:2});
					const laserGeometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(), new THREE.Vector3() ]);
					const laser = new THREE.Line(laserGeometry, laserMaterial); scene.add(laser);

					// Enemies container
					const enemies = [];
					const enemyGeo = new THREE.CircleGeometry(0.6,32);
					function spawnEnemy(){
						// spawn at random edge position and fly toward center
						const angle = Math.random()*Math.PI*2;
						const radius = 10 + Math.random()*2;
						const x = Math.cos(angle)*radius; const y = Math.sin(angle)*radius;
						const mat = new THREE.MeshBasicMaterial({color: new THREE.Color(`hsl(${Math.random()*60+0},80%,60%)`),opacity:0.95,transparent:true});
						const m = new THREE.Mesh(enemyGeo, mat);
						m.position.set(x,y,0);
						m.userData = {vel: new THREE.Vector3(-x*0.004 - Math.random()*0.002, -y*0.004 - Math.random()*0.002, 0), hp:1};
						scene.add(m); enemies.push(m);
						updateHUD();
					}

					// HUD helpers — keep references before spawn logic runs so updateHUD is safe
					const scoreVal = document.getElementById('scoreVal');
					const enemyCount = document.getElementById('enemyCount');
					let score = 0;
					function updateHUD(){ enemyCount.textContent = enemies.length; scoreVal.textContent = score; }

					for(let i=0;i<MAX_ENEMIES;i++) spawnEnemy();

					// Sound assets (small inlined audio beeps) using WebAudio
					const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					function playTone(freq=700, duration=0.08, gainVal=0.4){
						const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = freq; g.gain.value = gainVal;
						o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+duration);
					}

					// Message floating effect
					const msgLayer = document.getElementById('msgLayer');
					function floatingText(text,x,y,cls='hit'){
						const t = document.createElement('div'); t.className='floatingText '+cls; t.style.left=(x*100)+'%'; t.style.top=(y*100)+'%'; t.textContent=text; msgLayer.appendChild(t);
						requestAnimationFrame(()=>{ t.style.transform='translate(-50%,-50%) translateY(-40px)'; t.style.opacity='0'; });
						setTimeout(()=>t.remove(),800);
					}

					// Aim snapping (magnet) parameters
					const magnetRadius = 0.9; // snapping distance (world units)

					// Gesture detection state
					let lastDetectionTime = 0;
					let lastIndexPos = null;
					let firingLocked = false; // prevents auto-repeat

					// FPS tracking
					let lastFrameTime = performance.now(); let fpsCounter=0, fpsTimer=performance.now();

					// Setup MediaPipe Hands
					// The library was loaded from unpkg; ensure locateFile points to same version
					const hands = new Hands({
						locateFile: (file) => `${MEDIAPIPE_ASSET_BASE}${file}`
					});

					hands.setOptions({
						maxNumHands: 1,
						modelComplexity: 0,
						minDetectionConfidence: 0.6,
						minTrackingConfidence: 0.5
					});

					// Protect the detection loop with try/catch
					let lastResult = null;
					hands.onResults(results => {
						lastResult = results;
					});

					// create a MediaPipe camera util for pulling frames
					const cameraUtils = new Camera(video, {
						onFrame: async () => {
							// Throttle detection frequency
							const now = performance.now();
							if(now - lastDetectionTime > (1000 / AI_DETECTION_HZ)){
								lastDetectionTime = now;
								try{
									await hands.send({image: video});
								}catch(e){
									console.error('MediaPipe hands send failed — recovered safely', e);
								}
							}
						},
						width: 640, height: 480
					});
					cameraUtils.start();

					// Loading overlay hide once we see at least one frames processed
					let seenMpInit = false;
					const mpInitTimeout = setTimeout(()=>{ // safety: if MediaPipe does not produce results, still allow the game after 10s
						if(!seenMpInit){ overlay.style.display='none'; }
					}, 10000);

					// Main render loop
					function animate(){
						requestAnimationFrame(animate);

						// FPS calc
						const t = performance.now(); fpsCounter++; if(t - fpsTimer >= 1000){ document.getElementById('fps').textContent = Math.round(fpsCounter*1000/(t-fpsTimer)); fpsTimer = t; fpsCounter = 0; }

						// Move enemies
						for(let i=enemies.length-1;i>=0;i--){
							const e = enemies[i]; e.position.addScaledVector(e.userData.vel, 1);
							// If near center, bump score negative as missed
							if(e.position.length() < 0.6){
								scene.remove(e); enemies.splice(i,1);
								score = Math.max(0, score-5);
								floatingText('MISS', 50 + (Math.random()*10-5), 50 + (Math.random()*10-5));
								playTone(180,0.12,0.25);
							}
						}

						// refill enemies
						while(enemies.length < MAX_ENEMIES) spawnEnemy();

						// Gesture & aiming
						if(lastResult && lastResult.multiHandLandmarks && lastResult.multiHandLandmarks.length){
							seenMpInit = true; overlay.style.display='none'; clearTimeout(mpInitTimeout);
							const lm = lastResult.multiHandLandmarks[0];

							// Extract index fingertip and thumb tip
							const idx = lm[8]; // normalized coords
							const thumb = lm[4];

							// convert normalized coordinates into 3D world aiming plane
							// normalized coords: x [0,1] left->right, y [0,1] top->bottom
							const aimX = (idx.x - 0.5) * (window.innerWidth/window.innerHeight) * 12;
							const aimY = -(idx.y - 0.5) * 12;
							const aimPos = new THREE.Vector3(aimX, aimY, 0);

							// Magnet: snap reticle to nearest enemy within magnetRadius
							let snapped = null; let nearest = Infinity;
							enemies.forEach(e => { const d = e.position.distanceTo(aimPos); if(d < nearest){ nearest = d; snapped = e; }});
							if(nearest < magnetRadius){ reticle.position.copy(snapped.position); } else { reticle.position.copy(aimPos); }

							// Draw laser: from camera to reticle
							const p1 = new THREE.Vector3(0,0,10); const p2 = new THREE.Vector3(reticle.position.x, reticle.position.y, 0);
							laser.geometry.setFromPoints([p1,p2]);

							// Gesture detection: detect 'pistol' (index extended, others folded) + thumb tap to produce shoot
							// Simple heuristics: index tip is further from wrist than PIP (landmark 6); finger curl by comparing distances
							function isIndexExtended(){
								const indexDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
								const pipDist = Math.hypot(lm[6].x - lm[0].x, lm[6].y - lm[0].y);
								return indexDist > pipDist + 0.01;
							}
							function areOtherFingersCurled(){
								// middle, ring, pinky tips closer to wrist than their pips
								const isCurled = (tip,pip)=> (Math.hypot(lm[tip].x-lm[0].x,lm[tip].y-lm[0].y) < Math.hypot(lm[pip].x-lm[0].x,lm[pip].y-lm[0].y)+0.015);
								return isCurled(12,10) && isCurled(16,14) && isCurled(20,18);
							}
							function thumbNearIndex(){
								// small euclidean distance between tip and index tip
								const d = Math.hypot(idx.x - thumb.x, idx.y - thumb.y);
								return d < 0.055; // tuned threshold
							}

							const pistolPose = isIndexExtended() && areOtherFingersCurled();

							if(pistolPose && thumbNearIndex()){
								// fire
								if(!firingLocked){
									firingLocked = true; setTimeout(()=>{firingLocked=false;}, 160); // small debouncing
									// check hit on snapped or near enemies
									if(nearest < magnetRadius){ // hit
										snapped.userData.hp -= 1; if(snapped.userData.hp <= 0){
											// remove
											scene.remove(snapped); const idxp = enemies.indexOf(snapped); if(idxp>=0) enemies.splice(idxp,1);
											score += 10; playTone(1200,0.06,0.55); floatingText('HIT', 50 + (Math.random()*10-5), 45 + (Math.random()*10-10));
										}
									} else {
										// miss
										playTone(300,0.08,0.4); floatingText('MISS', 50 + (Math.random()*10-5), 55 + (Math.random()*8-4));
									}
								}
							}
						}

						renderer.render(scene,camera);
						updateHUD();
					}

					// start animation after a short warm-up
					requestAnimationFrame(animate);

					// Slightly longer hiding to make sure everything warmed up
					setTimeout(()=>{ if(!overlay.style.display) overlay.style.display='none'; }, 6000);

				}catch(err){
					console.error('游戏启动失败',err);
					document.getElementById('status').textContent = '启动失败：' + (err.message||err);
					setLoading(100,'失败 – 请检查浏览器控制台');
				}
			})();

			// Keep a heartbeat to ensure overlay progress moves even if asset fetches take time
			(function progressPulse(){
				let pct=10; setInterval(()=>{ pct = Math.min(100, pct + Math.random()*8); prog.style.width = pct + '%'; }, 500);
			})();

		</script>
	</body>
</html>
